package com.igeek.javase.day10.set;

import java.util.HashSet;

/**
 * @version 1.0
 * @Description HashSet类
 * @Author chenmin
 * @Date 2020/11/11 16:16
 *
 *  Set接口
 *  * 1.存储的元素是不可重复的
 *  * 2.丢失原存储顺序（元素都是无序的(即存取顺序不能保证不一致)）
 *  *
 *  * HashSet 实现类
 *  * 1.根据对象的哈希值来确定元素在集合中的存储位置，无序状态（存取顺序不能保证不一致）
 *  * 2.具有良好的存储和查找性能
 *  * 3.保证元素的唯一性 - equals()和hashCode()
 *  * 4.线程不安全的
 *
 *  思考：
 *  1.HashSet 怎么出现无序的情况的？
 *      底层计算hash值时，通过(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);计算
 *      计算对应添加元素的的“桶”数组的下标，通过(n - 1) & hash计算。
 *
 *  2.HashSet 如何保证元素的唯一性？
 *      根据hashcode()和equals()保证元素的唯一性。
 *      当hashcode一致时，equals不一定一致，需要查看equals是否一致，
 *              若equals一致，则认定为相同元素；
 *              若equals不一致，则认定为不同元素；
 *      当equals一致时，hashcode一定一致，直接认定是相同元素。
 *
 *  3.JDK8版本前后，底层存储结构有什么不同？为什么做出改变？
 *      1).底层是由数组 - 链表组成，当添加新元素时，它会根据元素的hash值找到对应的"桶"，也就是HashMap源码中Node<K, V> 里的元素，
 *  并插入到对应位置的链表中，链表元素个数过长时会转化为红黑树(JDK1.8后的版本)。
 *      2).链表取元素是从头结点一直遍历到对应的结点，这个过程的复杂度是O(N) ，而红黑树基于二叉树的结构，查找元素的复杂度为O(logN) ，
 *  所以，当元素个数过多时，用红黑树存储可以提高搜索的效率。
 *
 *  4.既然红黑树的效率高，那怎么不一开始就用红黑树存储呢？
 *      红黑树虽然查询效率比链表高，但是结点占用的空间大，只有达到一定的数目才有树化的意义，这是基于时间和空间的平衡考虑。
 *      此处翻译源代码注释：单个 TreeNode 需要占用的空间大约是普通Node的两倍，所以只有当包含足够多的Nodes时才会转成 TreeNodes，
 *  这个足够多的标准就是由 TREEIFY_THRESHOLD 的值（默认值8）决定的。而当桶中节点数由于移除或者 resize (扩容) 变少后，
 *  红黑树会转变为普通的链表，这个阈值是 UNTREEIFY_THRESHOLD（默认值6）。
 *
 *  5.为什么树化标准是8个？
 *      此处翻译源代码注释：如果hashCode的分布离散良好的话，那么红黑树是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。
 *  在理想情况下，链表长度符合“泊松分布”，各个长度的命中概率依次递减，注释中给我们展示了1-8长度的具体命中概率，当长度为8的时候，
 *  概率概率仅为0.00000006，这么小的概率，HashMap的红黑树转换几乎不会发生，因为我们日常使用不会存储那么多的数据。
 *      若用户使用HashMap过程导致hashCode分布离散很差的场景（思考一下是什么场景），这个时候再转换为红黑树就是一种很好的退让策略。
 *  可以避免查询效率低下的问题，从而有效防止用户自己实现了不好的哈希算法时导致链表过长的情况。
 *
 *  6.底层计算hash值时，为什么要(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);这样运算？
 *      传入key之后，hash()会获取key的hashCode进行无符号右移 16 位，然后进行按位异或，并把运算后的值返回，这个值就是key的哈希值。
 *  这样运算是为了减少碰撞冲突，因为大部分元素的hashCode在低位是相同的，不做处理的话很容易造成冲突。
 *
 *  7.如何计算对应添加元素的的“桶”数组的下标？
 *      tab[i = (n - 1) & hash]) 当查找不到对应的索引时，就会新建一个新的结点作为链表的头结点。
 *  通过位运算，在每次扩容时都不用重新计算hash，省去了不少时间，而且新增有效位是0还是1是带有随机性的，
 *  之前两个碰撞的Entry又有可能在扩容时再次均匀地散布开，达到较好的分布离散效果。
 *
 *  8.为什么退化为链表的阈值是6？
 *      当链表长度达到阈值8的时候会转为红黑树，但是红黑树退化为链表的阈值却是6。主要是一个过渡，避免链表和红黑树之间频繁的转换。
 * 如果阈值是7的话，删除一个元素红黑树就必须退化为链表，增加一个元素就必须树化，来回不断的转换结构无疑会降低性能，
 * 所以阈值才不设置的那么临界。
 *
 *
 */
public class HashSetDemo {

    public static void main(String[] args) {
        HashSet<Object> set = new HashSet<>();
        set.add("小强");
        set.add("小强");
        set.add(123);
        set.add(false);
        //小强  false  123
        for (Object o : set) {
            System.out.println(o);
        }
    }

}
